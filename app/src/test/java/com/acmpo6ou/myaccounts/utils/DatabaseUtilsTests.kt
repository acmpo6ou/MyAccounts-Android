/*
 * Copyright (c) 2020-2022. Bohdan Kolvakh
 * This file is part of MyAccounts.
 *
 * MyAccounts is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MyAccounts is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

package com.acmpo6ou.myaccounts.utils

import com.acmpo6ou.myaccounts.*
import com.acmpo6ou.myaccounts.core.MyApplication
import com.acmpo6ou.myaccounts.core.utils.DatabaseUtils
import com.acmpo6ou.myaccounts.database.databases_list.Database
import com.acmpo6ou.myaccounts.database.databases_list.DbMap
import com.macasaet.fernet.StringValidator
import com.macasaet.fernet.Token
import com.macasaet.fernet.Validator
import com.nhaarman.mockitokotlin2.doAnswer
import com.nhaarman.mockitokotlin2.doReturn
import com.nhaarman.mockitokotlin2.spy
import com.nhaarman.mockitokotlin2.whenever
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import java.io.File
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.time.Duration
import java.time.Instant
import java.time.temporal.TemporalAmount

open class DbUtils(override val app: MyApp) : DatabaseUtils

class DatabaseUtilsTests : ModelTest() {
    private lateinit var databaseUtils: DatabaseUtils
    lateinit var spyUtils: DatabaseUtils

    lateinit var myApp: MyApp
    val database = Database("test", "123", salt, mutableMapOf())

    @Before
    fun setup() {
        myApp = MyApplication()
        app = spy(myApp) {
            on { ACCOUNTS_DIR } doReturn accountsDir
            on { SRC_DIR } doReturn SRC_DIR
        }

        databaseUtils = DbUtils(app)
        spyUtils = spy(databaseUtils)
    }

    /**
     * Encrypts given map using [password] and [salt].
     *
     * @param[map] database map to encrypt.
     * @return encrypted json string of database map.
     */
    private fun encryptStr(map: DbMap): String {
        val key = deriveKey(password, salt)
        val data = dumps(map)
        val token = Token.generate(key, data)
        return token.serialise()
    }

    /**
     * Decrypts given [string].
     *
     * @param[string] string to decrypt.
     * @param[password] password for decryption.
     * @param[salt] salt for decryption.
     * @return decrypted string.
     */
    private fun decryptStr(string: String, password: String, salt: ByteArray): String {
        val key = deriveKey(password, salt)
        val validator: Validator<String> = object : StringValidator {
            // this checks whether our encrypted json string is expired or not
            // in our app we don't care about expiration so we return Instant.MAX.epochSecond
            override fun getTimeToLive(): TemporalAmount =
                Duration.ofSeconds(Instant.MAX.epochSecond)
        }
        val token = Token.fromString(string)
        return token.validateAndDecrypt(key, validator)
    }

    @Test
    fun `loads should return empty map when passed empty string`() {
        val loadMap = loads("")
        assertTrue(loadMap.isEmpty())
    }

    @Test
    fun `loads should return non empty map when passed non empty string`() {
        val map = loads(jsonDatabase)
        assertEquals(databaseMap, map)
    }

    @Test
    fun `dumps should return empty string when passed empty map`() {
        val dumpStr = dumps(mutableMapOf())
        assertTrue(dumpStr.isEmpty())
    }

    @Test
    fun `dumps should return serialized string when passed non empty map`() {
        val dumpStr = dumps(databaseMap)
        assertEquals(jsonDatabase, dumpStr)
    }

    @Test
    fun `decryptDatabase should return decrypted and deserialized map given string`() {
        val encryptedJson = encryptStr(databaseMap)
        val map = decryptDatabase(encryptedJson, password, salt)
        assertEquals(databaseMap, map)
    }

    @Test
    fun `decryptDatabase should cache generated by deriveKey key`() {
        val encryptedJson = encryptStr(databaseMap)
        decryptDatabase(encryptedJson, password, salt)

        val expectedKey = deriveKey(password, salt)
        assertEquals(app.keyCache[password], expectedKey)
    }

    @Test
    fun `encryptDatabase should cache key generated by deriveKey`() {
        val database = Database(faker.str(), password, salt, databaseMap)
        encryptDatabase(database)

        val expectedKey = deriveKey(password, salt)
        assertEquals(app.keyCache[password], expectedKey)
    }

    @Test
    fun `encryptDatabase should return encrypted json string from Database`() {
        val database = Database(faker.str(), faker.str(), salt, databaseMap)
        val jsonStr = encryptDatabase(database)

        // here we decrypt the json string using salt and password we defined earlier
        // to check if it were encrypted correctly
        val data = decryptStr(jsonStr, database.password!!, salt)
        assertEquals(jsonDatabase, data)
    }

    @Test
    fun `isDatabaseSaved should return false`() {
        // here database on disk is different then in-memory database
        val diskDatabase = Database("test", "123", salt, databaseMap)
        doReturn(diskDatabase).`when`(spyUtils).openDatabase(database)
        assertFalse(spyUtils.isDatabaseSaved(database))
    }

    @Test
    fun `isDatabaseSaved should return true`() {
        // here database on disk is exactly the same as database in memory
        doReturn(database).`when`(spyUtils).openDatabase(database)
        assertTrue(spyUtils.isDatabaseSaved(database))
    }

    @Test
    fun `isDatabaseSaved should return false when FileNotFoundException occurred`() {
        doAnswer {
            throw FileNotFoundException("")
        }.whenever(spyUtils).openDatabase(database)
        assertFalse(spyUtils.isDatabaseSaved(database))
    }

    @Test
    fun `openDatabase should return Database instance with non empty data property`() {
        copyDatabase("main")

        val db = Database("main", password, salt)
        val database = openDatabase(db)

        val expectedDatabase = Database("main", password, salt, databaseMap)
        assertEquals(expectedDatabase, database)
    }

    @Test
    fun `createDatabase should create dba file given Database instance`() {
        val database = Database("main", "123", salt, databaseMap)
        createDatabase(database)

        val file = File("$SRC_DIR/main.dba")
        val saltContent = ByteArray(16)
        var dbContent: ByteArray

        FileInputStream(file).use {
            it.read(saltContent)
            dbContent = it.readBytes()
        }

        // here we decrypt data saved to .dba file to check that it was encrypted correctly
        val data = decryptStr(String(dbContent), "123", salt)

        assertEquals(jsonDatabase, data)
        assertEquals(String(salt), String(saltContent))
    }

    @Test
    fun `deleteDatabase should remove dba file from disk`() {
        // create empty database so that we can delete it later
        val database = Database("main", "123", salt)
        createDatabase(database)

        deleteDatabase("main")

        val dbFile = File("$SRC_DIR/main.dba")
        assertFalse(dbFile.exists())
    }
}
